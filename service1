ROS2 ì¹´ë©”ë¼ ìŠ¤ëƒ…ìƒ· ì„œë¹„ìŠ¤ êµ¬í˜„ ê°€ì´ë“œ

 

1ë‹¨ê³„: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì¤€ë¹„

 

bash

# ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„± (ì´ë¯¸ ìˆë‹¤ë©´ ìŠ¤í‚µ)
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws/src

 

2ë‹¨ê³„: íŒ¨í‚¤ì§€ ìƒì„±

 

ì„œë¹„ìŠ¤ ì •ì˜ íŒ¨í‚¤ì§€ ìƒì„± (ë©”ì‹œì§€ íƒ€ì…)

 

bash

cd ~/ros2_ws/src
ros2 pkg create --build-type ament_cmake camera_interfaces

 

Request íŒ¨í‚¤ì§€ ìƒì„± (Service Client)

 

bash

ros2 pkg create --build-type ament_cmake opencv_webcam_request \
  --dependencies rclcpp std_srvs sensor_msgs

 

Response íŒ¨í‚¤ì§€ ìƒì„± (Service Server)

 

bash

ros2 pkg create --build-type ament_cmake opencv_webcam_response \
  --dependencies rclcpp std_srvs sensor_msgs cv_bridge OpenCV

 

3ë‹¨ê³„: ì»¤ìŠ¤í…€ ì„œë¹„ìŠ¤ ë©”ì‹œì§€ ì •ì˜ (camera_interfaces)

 

camera_interfacesë€?

 

camera_interfacesëŠ” ì»¤ìŠ¤í…€ ROS2 ë©”ì‹œì§€ë¥¼ ì •ì˜í•˜ëŠ” íŒ¨í‚¤ì§€ì…ë‹ˆë‹¤.

 

ì™œ í•„ìš”í•œê°€?

 

ROS2ì—ëŠ” ê¸°ë³¸ ì„œë¹„ìŠ¤ íƒ€ì…ë“¤(std_srvs/SetBool, std_srvs/Trigger ë“±)ì´ ìˆì§€ë§Œ, ìš°ë¦¬ê°€ ì›í•˜ëŠ” íŒŒì¼ëª…ì„ ë°›ê³ , ì €ì¥ ê²½ë¡œë¥¼ ë°˜í™˜í•˜ëŠ” ê¸°ëŠ¥ì€ ì—†ìŠµë‹ˆë‹¤

ë”°ë¼ì„œ ìš°ë¦¬ë§Œì˜ ì»¤ìŠ¤í…€ ì„œë¹„ìŠ¤ íƒ€ì…ì„ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤

 

ì‘ë™ ì›ë¦¬

 

.srv íŒŒì¼ì— ë©”ì‹œì§€ êµ¬ì¡° ì •ì˜

ë¹Œë“œ ì‹œ ìë™ìœ¼ë¡œ C++ í—¤ë” íŒŒì¼ ìƒì„±

ë‹¤ë¥¸ íŒ¨í‚¤ì§€ì—ì„œ #includeë¡œ ì‚¬ìš©

 

camera_interfaces íŒ¨í‚¤ì§€ êµ¬ì¡°

 

camera_interfaces/
â”œâ”€â”€ CMakeLists.txt          

### camera_interfaces/package.xml ìˆ˜ì •
```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>camera_interfaces</name>
  <version>0.0.1</version>
  <description>Custom camera service interfaces</description>
  <maintainer email="you@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>rosidl_default_generators</buildtool_depend>

  <exec_depend>rosidl_default_runtime</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

### camera_interfaces/CMakeLists.txt ìˆ˜ì •
```cmake
cmake_minimum_required(VERSION 3.8)
project(camera_interfaces)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rosidl_default_generators REQUIRED)

# ì„œë¹„ìŠ¤ íŒŒì¼ ì„ ì–¸
rosidl_generate_interfaces(${PROJECT_NAME}
  "srv/CaptureSnapshot.srv"
)

ament_package()
```

## 4ë‹¨ê³„: Service Server êµ¬í˜„ (opencv_webcam_response)

### opencv_webcam_response íŒ¨í‚¤ì§€ êµ¬ì¡°

1ë‹¨ê³„: í˜„ì¬ ìƒíƒœ í™•ì¸

 

bash

cd ~/ros2_ws/src/camera_interfaces
ls -la
ls -la srv/

 

2ë‹¨ê³„: srv ë””ë ‰í† ë¦¬ì™€ íŒŒì¼ ìƒì„±

 

bash

# camera_interfaces íŒ¨í‚¤ì§€ë¡œ ì´ë™
cd ~/ros2_ws/src/camera_interfaces

# srv ë””ë ‰í† ë¦¬ ìƒì„± (ì´ë¯¸ ìˆì–´ë„ ì—ëŸ¬ ì•ˆë‚¨)
mkdir -p srv

# CaptureSnapshot.srv íŒŒì¼ ìƒì„±
cat > srv/CaptureSnapshot.srv << 'EOF'
# Request
string filename
---
# Response
bool success
string message
string filepath
EOF

 

3ë‹¨ê³„: íŒŒì¼ í™•ì¸

 

bash

# íŒŒì¼ì´ ì œëŒ€ë¡œ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
cat srv/CaptureSnapshot.srv
```

**ì¶œë ¥ì´ ë‹¤ìŒê³¼ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤:**
```
# Request
string filename
---
# Response
bool success
string message
string filepath



 

opencv_webcam_response/ â”œâ”€â”€ CMakeLists.txt â”œâ”€â”€ package.xml â””â”€â”€ src/ â””â”€â”€ camera_server.cpp

 


### src/camera_server.cpp
```cpp
#include <opencv2/opencv.hpp>
#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/compressed_image.hpp>
#include <camera_interfaces/srv/capture_snapshot.hpp>
#include <cv_bridge/cv_bridge.h>

using namespace cv;
using namespace std::chrono_literals;

class CameraServerNode : public rclcpp::Node
{
private:
    VideoCapture cap_;
    rclcpp::Publisher<sensor_msgs::msg::CompressedImage>::SharedPtr publisher_;
    rclcpp::Service<camera_interfaces::srv::CaptureSnapshot>::SharedPtr snapshot_service_;
    rclcpp::TimerBase::SharedPtr timer_;
    
    int quality_ = 80;
    std::string save_directory_ = "./snapshots/";

public:
    CameraServerNode() : Node("camera_server_node")
    {
        // ì €ì¥ ë””ë ‰í† ë¦¬ ìƒì„±
        system(("mkdir -p " + save_directory_).c_str());
        
        // í¼ë¸”ë¦¬ì…” ìƒì„±
        publisher_ = this->create_publisher<sensor_msgs::msg::CompressedImage>(
            "/image_raw/compressed", 10);
        
        // ìŠ¤ëƒ…ìƒ· ì„œë¹„ìŠ¤ ìƒì„±
        snapshot_service_ = this->create_service<camera_interfaces::srv::CaptureSnapshot>(
            "capture_snapshot",
            std::bind(&CameraServerNode::handleSnapshotService, this,
                     std::placeholders::_1, std::placeholders::_2));
        
        // ì¹´ë©”ë¼ ì´ˆê¸°í™”
        if (!initCamera())
        {
            RCLCPP_ERROR(this->get_logger(), "Failed to initialize camera");
            rclcpp::shutdown();
            return;
        }
        
        // íƒ€ì´ë¨¸ë¡œ ì˜ìƒ í¼ë¸”ë¦¬ì‹œ
        timer_ = this->create_wall_timer(
            33ms, std::bind(&CameraServerNode::publishImage, this));
        
        RCLCPP_INFO(this->get_logger(), "Camera server node started");
        RCLCPP_INFO(this->get_logger(), "Snapshot service available at: /capture_snapshot");
        RCLCPP_INFO(this->get_logger(), "Save directory: %s", save_directory_.c_str());
    }
    
    ~CameraServerNode()
    {
        if (cap_.isOpened())
            cap_.release();
    }

private:
    bool initCamera()
    {
        cap_.open(0, cv::CAP_V4L2);
        if (!cap_.isOpened())
            return false;
        
        cap_.set(cv::CAP_PROP_FOURCC, cv::VideoWriter::fourcc('M', 'J', 'P', 'G'));
        cap_.set(cv::CAP_PROP_FRAME_WIDTH, 1280);
        cap_.set(cv::CAP_PROP_FRAME_HEIGHT, 720);
        cap_.set(cv::CAP_PROP_FPS, 15);
        
        return true;
    }
    
    void publishImage()
    {
        Mat frame;
        cap_ >> frame;
        
        if (frame.empty())
            return;
        
        // JPEG ì••ì¶•
        std::vector<uchar> buf;
        std::vector<int> params = {IMWRITE_JPEG_QUALITY, quality_};
        imencode(".jpg", frame, buf, params);
        
        // ROS2 ë©”ì‹œì§€ ìƒì„± ë° ë°œí–‰
        auto msg = std::make_shared<sensor_msgs::msg::CompressedImage>();
        msg->format = "jpeg";
        msg->data = std::move(buf);
        msg->header.stamp = this->now();
        msg->header.frame_id = "camera_frame";
        
        publisher_->publish(*msg);
    }
    
    // ìŠ¤ëƒ…ìƒ· ì„œë¹„ìŠ¤ ì½œë°±
    void handleSnapshotService(
        const std::shared_ptr<camera_interfaces::srv::CaptureSnapshot::Request> request,
        std::shared_ptr<camera_interfaces::srv::CaptureSnapshot::Response> response)
    {
        Mat frame;
        cap_ >> frame;
        
        if (frame.empty())
        {
            response->success = false;
            response->message = "Failed to capture frame from camera";
            response->filepath = "";
            RCLCPP_ERROR(this->get_logger(), "Failed to capture frame");
            return;
        }
        
        // íŒŒì¼ëª… ìƒì„±
        std::string filename = request->filename;
        if (filename.empty())
        {
            // ê¸°ë³¸ íŒŒì¼ëª…: snapshot_timestamp.jpg
            auto now = std::chrono::system_clock::now();
            auto timestamp = std::chrono::duration_cast<std::chrono::seconds>(
                now.time_since_epoch()).count();
            filename = "snapshot_" + std::to_string(timestamp) + ".jpg";
        }
        else if (filename.find(".jpg") == std::string::npos && 
                 filename.find(".png") == std::string::npos)
        {
            filename += ".jpg";
        }
        
        std::string filepath = save_directory_ + filename;
        
        // ì´ë¯¸ì§€ ì €ì¥
        if (imwrite(filepath, frame))
        {
            response->success = true;
            response->message = "Snapshot saved successfully";
            response->filepath = filepath;
            RCLCPP_INFO(this->get_logger(), "Snapshot saved: %s", filepath.c_str());
        }
        else
        {
            response->success = false;
            response->message = "Failed to save snapshot";
            response->filepath = "";
            RCLCPP_ERROR(this->get_logger(), "Failed to save snapshot");
        }
    }
};

int main(int argc, char** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<CameraServerNode>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

### opencv_webcam_response/package.xml
```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>opencv_webcam_response</name>
  <version>0.0.1</version>
  <description>Camera snapshot service server</description>
  <maintainer email="you@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>std_srvs</depend>
  <depend>sensor_msgs</depend>
  <depend>cv_bridge</depend>
  <depend>OpenCV</depend>
  <depend>camera_interfaces</depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

### opencv_webcam_response/CMakeLists.txt
```cmake
cmake_minimum_required(VERSION 3.8)
project(opencv_webcam_response)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_srvs REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(cv_bridge REQUIRED)
find_package(OpenCV REQUIRED)
find_package(camera_interfaces REQUIRED)

# camera_server ì‹¤í–‰íŒŒì¼
add_executable(camera_server src/camera_server.cpp)
ament_target_dependencies(camera_server 
  rclcpp 
  std_srvs 
  sensor_msgs 
  cv_bridge 
  OpenCV
  camera_interfaces
)

# ì„¤ì¹˜
install(TARGETS
  camera_server
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()
```

## 5ë‹¨ê³„: Service Client êµ¬í˜„ (opencv_webcam_request)

### opencv_webcam_request íŒ¨í‚¤ì§€ êµ¬ì¡°

 

opencv_webcam_request/ â”œâ”€â”€ CMakeLists.txt â”œâ”€â”€ package.xml â””â”€â”€ src/ â””â”€â”€ snapshot_client.cpp

 


### src/snapshot_client.cpp
```cpp
#include <rclcpp/rclcpp.hpp>
#include <camera_interfaces/srv/capture_snapshot.hpp>
#include <chrono>

using namespace std::chrono_literals;

class SnapshotClientNode : public rclcpp::Node
{
private:
    rclcpp::Client<camera_interfaces::srv::CaptureSnapshot>::SharedPtr client_;

public:
    SnapshotClientNode() : Node("snapshot_client_node")
    {
        client_ = this->create_client<camera_interfaces::srv::CaptureSnapshot>(
            "capture_snapshot");
        
        RCLCPP_INFO(this->get_logger(), "Snapshot client node started");
    }
    
    void sendRequest(const std::string& filename = "")
    {
        // ì„œë¹„ìŠ¤ ì„œë²„ ëŒ€ê¸°
        while (!client_->wait_for_service(1s))
        {
            if (!rclcpp::ok())
            {
                RCLCPP_ERROR(this->get_logger(), 
                    "Interrupted while waiting for service");
                return;
            }
            RCLCPP_INFO(this->get_logger(), 
                "Waiting for snapshot service...");
        }
        
        // ìš”ì²­ ìƒì„±
        auto request = std::make_shared<camera_interfaces::srv::CaptureSnapshot::Request>();
        request->filename = filename;
        
        RCLCPP_INFO(this->get_logger(), "Sending snapshot request...");
        
        // ë¹„ë™ê¸° ìš”ì²­
        auto result_future = client_->async_send_request(request);
        
        // ì‘ë‹µ ëŒ€ê¸°
        if (rclcpp::spin_until_future_complete(this->get_node_base_interface(), 
            result_future) == rclcpp::FutureReturnCode::SUCCESS)
        {
            auto result = result_future.get();
            
            if (result->success)
            {
                RCLCPP_INFO(this->get_logger(), "âœ“ Success!");
                RCLCPP_INFO(this->get_logger(), "  Message: %s", 
                    result->message.c_str());
                RCLCPP_INFO(this->get_logger(), "  Filepath: %s", 
                    result->filepath.c_str());
            }
            else
            {
                RCLCPP_ERROR(this->get_logger(), "âœ— Failed!");
                RCLCPP_ERROR(this->get_logger(), "  Message: %s", 
                    result->message.c_str());
            }
        }
        else
        {
            RCLCPP_ERROR(this->get_logger(), 
                "Failed to call service");
        }
    }
};

int main(int argc, char** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<SnapshotClientNode>();
    
    // ì»¤ë§¨ë“œë¼ì¸ ì¸ìì—ì„œ íŒŒì¼ëª… ê°€ì ¸ì˜¤ê¸°
    std::string filename = "";
    if (argc > 1)
    {
        filename = argv[1];
    }
    
    node->sendRequest(filename);
    
    rclcpp::shutdown();
    return 0;
}
```

### opencv_webcam_request/package.xml
```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>opencv_webcam_request</name>
  <version>0.0.1</version>
  <description>Camera snapshot service client</description>
  <maintainer email="you@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>std_srvs</depend>
  <depend>sensor_msgs</depend>
  <depend>camera_interfaces</depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

### opencv_webcam_request/CMakeLists.txt
```cmake
cmake_minimum_required(VERSION 3.8)
project(opencv_webcam_request)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_srvs REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(camera_interfaces REQUIRED)

# snapshot_client ì‹¤í–‰íŒŒì¼
add_executable(snapshot_client src/snapshot_client.cpp)
ament_target_dependencies(snapshot_client 
  rclcpp 
  std_srvs 
  sensor_msgs
  camera_interfaces
)

# ì„¤ì¹˜
install(TARGETS
  snapshot_client
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()
```

## 6ë‹¨ê³„: ë¹Œë“œ
```bash
cd ~/ros2_ws

# ì˜ì¡´ì„± ì„¤ì¹˜
rosdep install --from-paths src --ignore-src -r -y

# ë¹Œë“œ
colcon build --packages-select camera_interfaces opencv_webcam_response opencv_webcam_request

# í™˜ê²½ ì„¤ì •
source install/setup.bash
```

## 7ë‹¨ê³„: ì‹¤í–‰

### í„°ë¯¸ë„ 1: ì„œë¹„ìŠ¤ ì„œë²„ ì‹¤í–‰
```bash
cd ~/ros2_ws
source install/setup.bash
ros2 run opencv_webcam_response camera_server
```

### í„°ë¯¸ë„ 2: ì„œë¹„ìŠ¤ í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰

**ê¸°ë³¸ íŒŒì¼ëª…ìœ¼ë¡œ ìŠ¤ëƒ…ìƒ· ìº¡ì²˜:**
```bash
cd ~/ros2_ws
source install/setup.bash
ros2 run opencv_webcam_request snapshot_client
```

**ì»¤ìŠ¤í…€ íŒŒì¼ëª…ìœ¼ë¡œ ìŠ¤ëƒ…ìƒ· ìº¡ì²˜:**
```bash
ros2 run opencv_webcam_request snapshot_client "my_photo.jpg"
```

### í„°ë¯¸ë„ 3: CLIë¡œ ì„œë¹„ìŠ¤ í˜¸ì¶œ
```bash
# ê¸°ë³¸ íŒŒì¼ëª…
ros2 service call /capture_snapshot camera_interfaces/srv/CaptureSnapshot "{filename: ''}"

# ì»¤ìŠ¤í…€ íŒŒì¼ëª…
ros2 service call /capture_snapshot camera_interfaces/srv/CaptureSnapshot "{filename: 'test.jpg'}"
```

## 8ë‹¨ê³„: í™•ì¸
```bash
# ì„œë¹„ìŠ¤ ëª©ë¡ í™•ì¸
ros2 service list

# ì„œë¹„ìŠ¤ íƒ€ì… í™•ì¸
ros2 service type /capture_snapshot

# ì €ì¥ëœ ì´ë¯¸ì§€ í™•ì¸
ls -la ./snapshots/
```

## íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### ì¹´ë©”ë¼ ê¶Œí•œ ë¬¸ì œ
```bash
sudo usermod -a -G video $USER
# ë¡œê·¸ì•„ì›ƒ í›„ ë‹¤ì‹œ ë¡œê·¸ì¸
```

### OpenCV ì—†ìŒ
```bash
sudo apt install libopencv-dev
```

### cv_bridge ì—†ìŒ
```bash
sudo apt install ros-humble-cv-bridge
```

## ì™„ì„±! ğŸ‰

ì´ì œ ROS2 ì„œë¹„ìŠ¤ë¥¼ í†µí•´ ì¹´ë©”ë¼ ìŠ¤ëƒ…ìƒ·ì„ ìº¡ì²˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
